<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Delay the End</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Noto+Serif+SC:wght@400;700&family=Lora:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
/* ============================================
   CSS Variables & Reset
   ============================================ */
:root {
  /* Core palette */
  --bg-deep: #0d0d1a;
  --bg-surface: #1a1a2e;
  --parchment: #f4e8c1;
  --parchment-dim: #c4b896;
  --parchment-faint: rgba(244, 232, 193, 0.06);
  --ink: #2c2416;
  --gold: #c9a84c;
  --gold-dim: rgba(201, 168, 76, 0.3);
  --blood: #8b2e2e;
  --blood-glow: rgba(139, 46, 46, 0.4);
  --heaven-blue: #6e8ca8;
  --hell-amber: #c46a32;
  --stability-green: #5a8a5e;
  --pressure-red: #a83232;
  --ghost: rgba(244, 232, 193, 0.12);

  /* Typography */
  --font-display: 'Playfair Display', 'Noto Serif SC', Georgia, serif;
  --font-body: 'Lora', 'Noto Serif SC', Georgia, serif;
  --font-zh: 'Noto Serif SC', '宋体', serif;

  /* Spacing */
  --space-xs: 0.5rem;
  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 4rem;
  --space-xl: 6rem;
}

*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

html { font-size: 16px; -webkit-font-smoothing: antialiased; }

body {
  background: var(--bg-deep);
  color: var(--parchment);
  font-family: var(--font-body);
  min-height: 100vh;
  min-height: 100dvh;
  overflow-x: hidden;
}

/* ============================================
   Texture & Atmosphere Layer
   ============================================ */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    linear-gradient(rgba(13, 13, 26, 0.78), rgba(13, 13, 26, 0.9)),
    url("./assets/bg/IrisZhou_dark_atmospheric_London_street_illustration_fog_vint_60d8b786-7b09-4b1b-9b2b-364226ea47bd_2.png"),
    radial-gradient(ellipse at 20% 50%, rgba(110, 140, 168, 0.03) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 50%, rgba(196, 106, 50, 0.03) 0%, transparent 60%),
    radial-gradient(ellipse at 50% 100%, rgba(139, 46, 46, 0.05) 0%, transparent 50%);
  background-size: auto, cover, auto, auto, auto;
  background-position: center center;
  background-repeat: no-repeat;
  transform: translateZ(0);
  will-change: transform;
  pointer-events: none;
  z-index: 0;
}

/* Noise grain overlay */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  opacity: 0.035;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 1;
}

.decor-layer {
  position: fixed;
  inset: 0;
  z-index: 4;
  pointer-events: none;
}

.decor-item {
  position: absolute;
  width: clamp(72px, 10vw, 140px);
  opacity: 0.18;
  filter: sepia(0.28) saturate(0.88) brightness(0.9);
}

.decor-item.glasses {
  top: 10vh;
  right: 7vw;
  transform: rotate(-12deg);
}

.decor-item.coffee {
  bottom: 12vh;
  left: 8vw;
  transform: rotate(7deg);
}

.decor-item.book {
  top: 22vh;
  left: 6vw;
  transform: rotate(-8deg);
}

.decor-item.car {
  bottom: 7vh;
  right: 8vw;
  transform: rotate(5deg);
}

/* ============================================
   SVG Icon Definitions (Hidden, referenced by <use>)
   ============================================ */
.svg-defs { position: absolute; width: 0; height: 0; overflow: hidden; }

/* ============================================
   Landing Page
   ============================================ */
.landing {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding:
    max(env(safe-area-inset-top), clamp(1rem, 4vh, 2.5rem))
    1rem
    max(env(safe-area-inset-bottom), 1.2rem);
  overflow-y: auto;
  overscroll-behavior: contain;
  z-index: 100;
  background: var(--bg-deep);
  transition: opacity 1.2s ease;
}

.landing.fade-out {
  opacity: 0;
  pointer-events: none;
}

/* Prologue text — typewriter */
.prologue {
  text-align: center;
  opacity: 0;
  animation: fadeIn 1.5s ease 0.5s forwards;
}

.prologue-en {
  font-family: var(--font-display);
  font-style: italic;
  font-size: 1.15rem;
  color: var(--parchment-dim);
  letter-spacing: 0.08em;
  margin-bottom: 0.6rem;
}

.prologue-zh {
  font-family: var(--font-zh);
  font-size: 1rem;
  color: var(--parchment-dim);
  opacity: 0.7;
}

.prologue.hide {
  animation: fadeOut 1.5s ease forwards;
}

/* Main title */
.landing-title {
  text-align: center;
  opacity: 0;
  transform: translateY(12px);
}

.landing-title.show {
  animation: riseIn 2s ease forwards;
}

.landing-title h1 {
  font-family: var(--font-display);
  font-size: clamp(2.4rem, 6vw, 4.5rem);
  font-weight: 700;
  color: var(--parchment);
  letter-spacing: 0.15em;
  text-transform: uppercase;
  margin-bottom: 0.3em;
  text-shadow: 0 0 60px rgba(201, 168, 76, 0.15);
}

.landing-title .subtitle {
  font-family: var(--font-display);
  font-style: italic;
  font-size: clamp(0.9rem, 2vw, 1.15rem);
  color: var(--parchment-dim);
  letter-spacing: 0.06em;
  line-height: 1.8;
  max-width: min(92vw, 760px);
  white-space: normal;
  text-wrap: balance;
  margin: 0 auto;
}

.landing-cta {
  margin-top: clamp(1rem, 5vh, 2.5rem);
}

.landing-title .subtitle-zh {
  font-family: var(--font-zh);
  font-style: normal;
  display: block;
  margin-top: 0.4em;
  font-size: 0.95em;
  opacity: 0.7;
}

/* Decorative line */
.landing-divider {
  width: 80px;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
  margin: var(--space-md) auto;
  opacity: 0;
}

.landing-divider.show {
  animation: fadeIn 1.5s ease forwards;
}

/* CTA Button */
.cta-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.7em;
  font-family: var(--font-display);
  font-size: 1rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: var(--parchment);
  background: transparent;
  border: 1px solid var(--gold-dim);
  padding: 0.9em 2.4em;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  opacity: 0;
  transition: all 0.4s ease;
  white-space: nowrap;
}

.cta-en,
.cta-zh {
  display: inline-block;
}

.cta-sep {
  opacity: 0.8;
  letter-spacing: 0;
}

.cta-btn.show {
  animation: fadeIn 1s ease forwards;
}

.cta-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(201, 168, 76, 0.08), transparent);
  opacity: 0;
  transition: opacity 0.4s ease;
}

.cta-btn:hover {
  border-color: var(--gold);
  box-shadow: 0 0 30px rgba(201, 168, 76, 0.1), inset 0 0 30px rgba(201, 168, 76, 0.05);
}

.cta-btn:hover::before { opacity: 1; }

/* Breathing glow on CTA */
.cta-btn.show {
  animation: fadeIn 1s ease forwards, breathe 4s ease-in-out 2s infinite;
}

/* Decorative corner marks on landing */
.corner-mark {
  position: fixed;
  width: 40px;
  height: 40px;
  opacity: 0;
  transition: opacity 2s ease;
}
.corner-mark.show { opacity: 0.15; }
.corner-mark svg { width: 100%; height: 100%; }

.corner-mark.tl { top: 30px; left: 30px; }
.corner-mark.tr { top: 30px; right: 30px; transform: scaleX(-1); }
.corner-mark.bl { bottom: 30px; left: 30px; transform: scaleY(-1); }
.corner-mark.br { bottom: 30px; right: 30px; transform: scale(-1, -1); }

/* ============================================
   Game Container (hidden during landing)
   ============================================ */
.game-container {
  display: none;
  max-width: 800px;
  margin: 0 auto;
  padding: var(--space-md);
  min-height: 100vh;
  min-height: 100dvh;
  position: relative;
  z-index: 10;
}

.game-container.active {
  display: block;
  animation: fadeIn 1.5s ease;
}

/* ---- Top Bar: Language Toggle + Round ---- */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.6rem;
  padding-bottom: var(--space-sm);
  border-bottom: 1px solid var(--ghost);
  margin-bottom: var(--space-md);
}

.round-indicator {
  font-family: var(--font-display);
  font-size: 0.85rem;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--parchment-dim);
}

.lang-toggle {
  font-family: var(--font-body);
  font-size: 0.8rem;
  color: var(--parchment-dim);
  background: none;
  border: 1px solid var(--ghost);
  padding: 0.3em 0.8em;
  cursor: pointer;
  letter-spacing: 0.05em;
  transition: all 0.3s ease;
}

.lang-toggle:hover {
  border-color: var(--gold-dim);
  color: var(--parchment);
}

/* ---- Stat Bars ---- */
.stat-bars {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-sm) var(--space-md);
  margin-bottom: var(--space-lg);
}

.stat-item {
  display: flex;
  align-items: center;
  gap: 0.7rem;
}

.stat-icon {
  width: 28px;
  height: 28px;
  flex-shrink: 0;
  opacity: 0.85;
}

.stat-info { flex: 1; }

.stat-label {
  font-family: var(--font-display);
  font-size: 0.75rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--parchment-dim);
  margin-bottom: 0.3em;
  display: flex;
  justify-content: space-between;
}

.stat-value {
  font-family: var(--font-display);
  font-size: 0.75rem;
  color: var(--parchment);
}

.stat-bar-track {
  width: 100%;
  height: 6px;
  background: var(--ghost);
  border-radius: 1px;
  overflow: hidden;
  position: relative;
}

.stat-bar-fill {
  height: 100%;
  border-radius: 1px;
  transition: width 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  position: relative;
}

.stat-bar-fill.heaven { background: linear-gradient(90deg, var(--heaven-blue), #8aa8c4); }
.stat-bar-fill.hell   { background: linear-gradient(90deg, var(--hell-amber), #d4884a); }
.stat-bar-fill.stability { background: linear-gradient(90deg, var(--stability-green), #7aaa7e); }
.stat-bar-fill.pressure  { background: linear-gradient(90deg, var(--pressure-red), #c84848); }

/* Tick marks on bar */
.stat-bar-track::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    90deg,
    transparent,
    transparent 9.8%,
    rgba(244, 232, 193, 0.08) 9.8%,
    rgba(244, 232, 193, 0.08) 10.2%
  );
  z-index: 1;
}

/* ---- Event Card ---- */
.event-card {
  background: rgba(244, 232, 193, 0.03);
  border: 1px solid var(--ghost);
  padding: var(--space-md);
  margin-bottom: var(--space-md);
  position: relative;
}

.event-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: 3px;
  height: 100%;
  background: linear-gradient(180deg, var(--gold-dim), transparent);
}

.event-title {
  font-family: var(--font-display);
  font-size: 1.4rem;
  font-weight: 700;
  color: var(--parchment);
  margin-bottom: var(--space-sm);
  letter-spacing: 0.03em;
}

.event-text {
  font-family: var(--font-body);
  font-size: 0.95rem;
  line-height: 1.85;
  white-space: pre-line;
  overflow-wrap: anywhere;
  color: var(--parchment-dim);
  margin-bottom: var(--space-md);
}

/* ---- Choice Buttons ---- */
.choices {
  display: flex;
  flex-direction: column;
  gap: 0.7rem;
}

.choice-btn {
  display: block;
  width: 100%;
  text-align: left;
  font-family: var(--font-body);
  font-size: 0.9rem;
  color: var(--parchment);
  background: rgba(244, 232, 193, 0.04);
  border: 1px solid rgba(244, 232, 193, 0.1);
  padding: 1em 1.4em;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  line-height: 1.5;
}

.choice-btn:hover {
  background: rgba(244, 232, 193, 0.08);
  border-color: var(--gold-dim);
  padding-left: 1.8em;
}

.choice-btn .choice-id {
  font-family: var(--font-display);
  font-weight: 700;
  color: var(--gold);
  margin-right: 0.6em;
  font-size: 0.85em;
}

.choice-btn.extreme {
  border-left: 2px solid var(--blood);
}

.choice-btn.extreme:hover {
  border-color: var(--blood);
  box-shadow: inset 3px 0 12px var(--blood-glow);
}

/* ---- Record Phase ---- */
.record-phase {
  margin-top: var(--space-md);
  padding-top: var(--space-md);
  border-top: 1px solid var(--ghost);
}

.record-title {
  font-family: var(--font-display);
  font-size: 0.85rem;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--parchment-dim);
  margin-bottom: var(--space-sm);
}

.record-choices {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.6rem;
}

.record-btn {
  font-family: var(--font-body);
  font-size: 0.82rem;
  color: var(--parchment-dim);
  background: rgba(201, 168, 76, 0.04);
  border: 1px solid rgba(201, 168, 76, 0.12);
  padding: 0.8em 1em;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: center;
  line-height: 1.4;
}

.record-btn:hover {
  color: var(--parchment);
  background: rgba(201, 168, 76, 0.08);
  border-color: var(--gold-dim);
}

/* ---- Feedback Toast ---- */
.feedback {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  font-family: var(--font-display);
  font-size: 0.85rem;
  color: var(--parchment);
  background: var(--bg-surface);
  border: 1px solid var(--gold-dim);
  padding: 0.8em 1.6em;
  opacity: 0;
  transition: all 0.5s ease;
  z-index: 200;
  pointer-events: none;
  letter-spacing: 0.05em;
  text-align: center;
  max-width: 500px;
}

.feedback.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* ---- Ending Screen ---- */
.ending-screen {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg-deep);
  z-index: 150;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  overflow-y: auto;
  padding:
    max(env(safe-area-inset-top), clamp(1.2rem, 4vh, var(--space-lg)))
    clamp(1rem, 4vw, var(--space-lg))
    max(env(safe-area-inset-bottom), 2.2rem);
  text-align: center;
}

.ending-screen.active {
  display: flex;
  animation: fadeIn 2s ease;
}

.ending-title {
  font-family: var(--font-display);
  font-size: clamp(1.8rem, 4vw, 3rem);
  font-weight: 700;
  color: var(--parchment);
  letter-spacing: 0.1em;
  margin-bottom: var(--space-sm);
}

.ending-text {
  font-family: var(--font-body);
  font-size: 1.05rem;
  line-height: 2;
  white-space: pre-line;
  overflow-wrap: anywhere;
  color: var(--parchment-dim);
  max-width: min(92vw, 680px);
  margin-left: auto;
  margin-right: auto;
  text-align: left;
  margin-bottom: var(--space-lg);
}

.ending-stats {
  display: flex;
  gap: var(--space-md);
  margin-bottom: var(--space-lg);
  flex-wrap: wrap;
  justify-content: center;
}

.ending-stat {
  text-align: center;
}

.ending-stat-label {
  font-family: var(--font-display);
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--parchment-dim);
  margin-bottom: 0.3em;
}

.ending-stat-value {
  font-family: var(--font-display);
  font-size: 1.4rem;
  color: var(--parchment);
}

.replay-btn {
  font-family: var(--font-display);
  font-size: 0.85rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--parchment-dim);
  background: none;
  border: 1px solid var(--ghost);
  padding: 0.8em 2em;
  cursor: pointer;
  transition: all 0.3s ease;
}

.replay-btn:hover {
  color: var(--parchment);
  border-color: var(--gold-dim);
}

/* ============================================
   Animations
   ============================================ */
@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to   { opacity: 0; }
}

@keyframes riseIn {
  from { opacity: 0; transform: translateY(12px); }
  to   { opacity: 1; transform: translateY(0); }
}

@keyframes breathe {
  0%, 100% { box-shadow: 0 0 15px rgba(201, 168, 76, 0.05); }
  50%      { box-shadow: 0 0 25px rgba(201, 168, 76, 0.12); }
}

/* ============================================
   Responsive
   ============================================ */
@media (max-width: 600px) {
  .stat-bars { grid-template-columns: 1fr; }
  .record-choices { grid-template-columns: 1fr; }
  .ending-stats { flex-direction: column; align-items: center; }
  .event-card { padding: var(--space-sm); }
  .game-container { padding: var(--space-sm); }
  .top-bar { flex-wrap: wrap; }
  .landing-title h1 {
    letter-spacing: 0.11em;
    font-size: clamp(2rem, 12vw, 3.2rem);
  }
  .landing-title .subtitle {
    max-width: 92vw;
    line-height: 1.7;
  }
  .cta-btn {
    width: min(92vw, 500px);
    letter-spacing: 0.14em;
    font-size: 0.95rem;
    padding: 0.95em 1.2em;
  }
  .cta-en {
    letter-spacing: 0.12em;
  }
  .cta-zh {
    letter-spacing: 0.1em;
  }
  .ending-title {
    letter-spacing: 0.05em;
  }
  .ending-text {
    max-width: 88vw;
    font-size: 1rem;
    line-height: 1.9;
  }
  .decor-item { opacity: 0.12; width: clamp(60px, 18vw, 100px); }
  .decor-item.book,
  .decor-item.car { display: none; }
}

@media (max-height: 760px) {
  .landing {
    justify-content: flex-start;
  }
  .ending-screen {
    justify-content: flex-start;
  }
}

@media (hover: none) and (pointer: coarse) {
  body::before {
    background-size: auto, cover, auto, auto, auto;
  }
}

@media (max-width: 420px) {
  .cta-btn {
    flex-direction: column;
    gap: 0.35em;
    letter-spacing: 0.1em;
  }
  .cta-sep {
    display: none;
  }
}
</style>
</head>
<body>

<div class="decor-layer" aria-hidden="true">
  <img class="decor-item glasses" src="./assets/decorations/glasses.PNG" alt="">
  <img class="decor-item coffee" src="./assets/decorations/coffee-and-coco.PNG" alt="">
  <img class="decor-item book" src="./assets/decorations/old-book.PNG" alt="">
  <img class="decor-item car" src="./assets/decorations/classic-car.PNG" alt="">
</div>

<!-- ==========================================
     SVG Symbol Definitions
     ========================================== -->
<svg class="svg-defs" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- HEAVEN: Feather quill with halo arc -->
    <symbol id="icon-heaven" viewBox="0 0 32 32">
      <path d="M16 4 C16 4 10 8 8 14 C6 20 8 26 16 28 C16 28 12 20 14 14 C15 11 16 8 16 4Z"
            fill="none" stroke="#6e8ca8" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M16 4 C16 4 22 8 24 14 C26 20 24 26 16 28"
            fill="none" stroke="#6e8ca8" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" opacity="0.5"/>
      <line x1="16" y1="6" x2="16" y2="28"
            stroke="#6e8ca8" stroke-width="0.8" opacity="0.4"/>
      <!-- Halo arc -->
      <path d="M10 5 A8 4 0 0 1 22 5"
            fill="none" stroke="#6e8ca8" stroke-width="0.8" opacity="0.35"/>
    </symbol>

    <!-- HELL: Serpentine flame -->
    <symbol id="icon-hell" viewBox="0 0 32 32">
      <path d="M16 28 C16 28 8 22 8 16 C8 12 10 10 12 11 C10 8 12 4 16 4 C20 4 22 8 20 11 C22 10 24 12 24 16 C24 22 16 28 16 28Z"
            fill="none" stroke="#c46a32" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      <!-- Inner serpent tongue -->
      <path d="M14 20 C14 16 16 14 16 10"
            fill="none" stroke="#c46a32" stroke-width="0.8" stroke-linecap="round" opacity="0.5"/>
      <path d="M16 10 L14.5 8 M16 10 L17.5 8"
            fill="none" stroke="#c46a32" stroke-width="0.8" stroke-linecap="round" opacity="0.5"/>
      <!-- Eye -->
      <circle cx="16" cy="16" r="1" fill="#c46a32" opacity="0.6"/>
    </symbol>

    <!-- STABILITY: Balanced scale / house frame -->
    <symbol id="icon-stability" viewBox="0 0 32 32">
      <!-- Roof -->
      <path d="M16 4 L4 16 L28 16 Z"
            fill="none" stroke="#5a8a5e" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      <!-- Walls -->
      <line x1="8" y1="16" x2="8" y2="26"
            stroke="#5a8a5e" stroke-width="1.2" stroke-linecap="round"/>
      <line x1="24" y1="16" x2="24" y2="26"
            stroke="#5a8a5e" stroke-width="1.2" stroke-linecap="round"/>
      <!-- Ground -->
      <line x1="6" y1="26" x2="26" y2="26"
            stroke="#5a8a5e" stroke-width="1.2" stroke-linecap="round"/>
      <!-- Door -->
      <rect x="13" y="19" width="6" height="7"
            fill="none" stroke="#5a8a5e" stroke-width="0.8" rx="1" opacity="0.5"/>
      <!-- Window -->
      <circle cx="16" cy="12" r="1.5"
              fill="none" stroke="#5a8a5e" stroke-width="0.8" opacity="0.4"/>
    </symbol>

    <!-- PRESSURE: Cracked hourglass -->
    <symbol id="icon-pressure" viewBox="0 0 32 32">
      <!-- Frame -->
      <line x1="8" y1="4" x2="24" y2="4"
            stroke="#a83232" stroke-width="1.5" stroke-linecap="round"/>
      <line x1="8" y1="28" x2="24" y2="28"
            stroke="#a83232" stroke-width="1.5" stroke-linecap="round"/>
      <!-- Glass body -->
      <path d="M10 4 C10 4 10 12 16 16 C10 20 10 28 10 28"
            fill="none" stroke="#a83232" stroke-width="1.2" stroke-linecap="round"/>
      <path d="M22 4 C22 4 22 12 16 16 C22 20 22 28 22 28"
            fill="none" stroke="#a83232" stroke-width="1.2" stroke-linecap="round"/>
      <!-- Sand trickle -->
      <line x1="16" y1="14" x2="16" y2="18"
            stroke="#a83232" stroke-width="0.8" opacity="0.5" stroke-dasharray="1 2"/>
      <!-- Crack -->
      <path d="M18 10 L20 12 L18 14"
            fill="none" stroke="#a83232" stroke-width="0.7" opacity="0.4"/>
    </symbol>

    <!-- Corner ornament -->
    <symbol id="corner-ornament" viewBox="0 0 40 40">
      <path d="M0 0 L20 0 L20 3 L3 3 L3 20 L0 20 Z" fill="none" stroke="#c9a84c" stroke-width="0.5" opacity="0.6"/>
      <circle cx="5" cy="5" r="1" fill="#c9a84c" opacity="0.3"/>
    </symbol>
  </defs>
</svg>

<!-- ==========================================
     Landing Page
     ========================================== -->
<div class="landing" id="landing">
  <!-- Corner ornaments -->
  <div class="corner-mark tl" id="corner-tl"><svg><use href="#corner-ornament"/></svg></div>
  <div class="corner-mark tr" id="corner-tr"><svg><use href="#corner-ornament"/></svg></div>
  <div class="corner-mark bl" id="corner-bl"><svg><use href="#corner-ornament"/></svg></div>
  <div class="corner-mark br" id="corner-br"><svg><use href="#corner-ornament"/></svg></div>

  <!-- Phase 1: Prologue -->
  <div class="prologue" id="prologue">
    <div class="prologue-en">The angel and the demon had an Arrangement.</div>
    <div class="prologue-zh">天使和恶魔有一个约定。</div>
  </div>

  <!-- Phase 2: Title -->
  <div class="landing-title" id="landing-title">
    <h1>Delay the End</h1>
    <div class="landing-divider" id="landing-divider"></div>
    <div class="subtitle">
      You cannot stop what is written. You can only delay it.
      <span class="subtitle-zh">你无法阻止已写下的预言。你只能延缓它。</span>
    </div>
  </div>

  <!-- Phase 3: CTA -->
  <div class="landing-cta">
    <button class="cta-btn" id="cta-btn" onclick="startGame()">
      <span class="cta-en">Begin Your Record</span>
      <span class="cta-sep">/</span>
      <span class="cta-zh">开始记录</span>
    </button>
  </div>
</div>

<!-- ==========================================
     Game Container
     ========================================== -->
<div class="game-container" id="game-container">
  <!-- Top bar -->
  <div class="top-bar">
    <div class="round-indicator" id="round-indicator">Round 1 / 7</div>
    <button class="lang-toggle" id="lang-toggle" onclick="toggleLanguage()">EN / 中</button>
  </div>

  <!-- Stat bars -->
  <div class="stat-bars">
    <div class="stat-item">
      <svg class="stat-icon"><use href="#icon-heaven"/></svg>
      <div class="stat-info">
        <div class="stat-label">
          <span>Heaven</span>
          <span class="stat-value" id="stat-heaven-val">50</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill heaven" id="stat-heaven-bar" style="width: 50%"></div>
        </div>
      </div>
    </div>
    <div class="stat-item">
      <svg class="stat-icon"><use href="#icon-hell"/></svg>
      <div class="stat-info">
        <div class="stat-label">
          <span>Hell</span>
          <span class="stat-value" id="stat-hell-val">50</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill hell" id="stat-hell-bar" style="width: 50%"></div>
        </div>
      </div>
    </div>
    <div class="stat-item">
      <svg class="stat-icon"><use href="#icon-stability"/></svg>
      <div class="stat-info">
        <div class="stat-label">
          <span>Stability</span>
          <span class="stat-value" id="stat-stability-val">50</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill stability" id="stat-stability-bar" style="width: 50%"></div>
        </div>
      </div>
    </div>
    <div class="stat-item">
      <svg class="stat-icon"><use href="#icon-pressure"/></svg>
      <div class="stat-info">
        <div class="stat-label">
          <span>Pressure</span>
          <span class="stat-value" id="stat-pressure-val">0</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill pressure" id="stat-pressure-bar" style="width: 0%"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Event card (populated by JS) -->
  <div class="event-card" id="event-card">
    <div class="event-title" id="event-title">—</div>
    <div class="event-text" id="event-text">Loading...</div>
    <div class="choices" id="choices-container"></div>
  </div>

  <!-- Record phase (hidden until triggered) -->
  <div class="record-phase" id="record-phase" style="display: none;">
    <div class="record-title" id="record-title">Archive Phase — 记录阶段</div>
    <div class="record-choices">
      <button class="record-btn" onclick="handleRecord('truth')">
        <span data-en="Record Truthfully" data-zh="如实记录">如实记录</span>
      </button>
      <button class="record-btn" onclick="handleRecord('polish')">
        <span data-en="Embellish for Heaven" data-zh="美化记录">美化记录</span>
      </button>
      <button class="record-btn" onclick="handleRecord('blur')">
        <span data-en="Obscure for Hell" data-zh="模糊记录">模糊记录</span>
      </button>
      <button class="record-btn" onclick="handleRecord('seal')">
        <span data-en="Seal the Archive" data-zh="封存档案">封存档案</span>
      </button>
    </div>
  </div>

</div>

<!-- Feedback toast -->
<div class="feedback" id="feedback"></div>

<!-- Ending screen -->
<div class="ending-screen" id="ending-screen">
  <div class="ending-title" id="ending-title"></div>
  <div class="ending-text" id="ending-text"></div>
  <div class="ending-stats" id="ending-stats"></div>
  <button class="replay-btn" onclick="location.reload()">Play Again / 重新开始</button>
</div>

<!-- ==========================================
     Landing Page Animation Script
     ========================================== -->
<script>
let TOTAL_ROUNDS = 7;
let PRESSURE_GROWTH = [3, 4, 5, 6, 8, 10, 12];

let EVENTS_DATA = [];
let ENDINGS_DATA = { meta: {}, endings: [], priority: [] };

const DEFAULT_GAME_CONFIG = {
  rounds: 7,
  pressure_growth: [3, 4, 5, 6, 8, 10, 12],
  initial: {
    heaven: 50,
    hell: 50,
    stability: 50,
    pressure: 0
  },
  record: {
    truth_streak_target: 3,
    truth_stability_bonus: 3,
    polish_heaven_bonus: 2,
    blur_hell_bonus: 2,
    seal_pressure_delta: -2,
    seal_penalty_chance: 0.2,
    seal_penalty: {
      stability: -5,
      heaven: 3
    }
  },
  rebellion: {
    balance_diff_max: 10,
    stability_min: 65,
    consecutive_required: 3,
    max_extreme_choices: 1
  },
  endings: {
    stability_collapse_lt: 20,
    heaven_dominance_gte: 90,
    hell_dominance_gte: 90,
    rebellion_pressure_lt: 85
  }
};

let GAME_CONFIG = cloneDeep(DEFAULT_GAME_CONFIG);

const DATA_PATHS = {
  events: "./data/events.json",
  endings: "./data/endings.json",
  config: "./data/game-config.json"
};

const TEXTS = {
  sealPenalty: {
    en: "Heaven's auditors have noticed a gap in the archives. Trust erodes.",
    zh: "天堂的审计员注意到了档案中的空白。信任正在瓦解。"
  },
  truthBonus: {
    en: "Your honest record has earned quiet respect among the mortals.",
    zh: "你如实的记录在凡人中赢得了无声的尊重。"
  },
  round: {
    en: "Round",
    zh: "第"
  },
  recordTitle: {
    en: "Archive Phase",
    zh: "记录阶段"
  },
  selected: {
    en: "Selected",
    zh: "已选择"
  },
  noShift: {
    en: "No significant shift.",
    zh: "数值无明显变化。"
  },
  effectPrefix: {
    en: "Result",
    zh: "结果"
  },
  loading: {
    en: "Loading archives...",
    zh: "正在加载档案..."
  },
  initErrorTitle: {
    en: "Archive Connection Failed",
    zh: "档案连接失败"
  },
  initErrorBody: {
    en: "Could not load game data. If you opened this file directly, run it via a local static server.",
    zh: "无法加载游戏数据。如果你是直接双击打开 HTML，请使用本地静态服务器运行。"
  },
  retry: {
    en: "Retry",
    zh: "重试"
  }
};

const STAT_LABELS = {
  en: {
    heaven: "Heaven",
    hell: "Hell",
    stability: "Stability",
    pressure: "Pressure"
  },
  zh: {
    heaven: "天堂",
    hell: "地狱",
    stability: "稳定度",
    pressure: "压力"
  }
};

const RECORD_ACTION_MAP = {
  truth: {
    en: "Record Truthfully",
    zh: "如实记录"
  },
  polish: {
    en: "Embellish for Heaven",
    zh: "美化记录"
  },
  blur: {
    en: "Obscure for Hell",
    zh: "模糊记录"
  },
  seal: {
    en: "Seal the Archive",
    zh: "封存档案"
  }
};

let gameState = null;
let gameStarted = false;
let feedbackTimer = null;
let activeEndingId = null;

function cloneDeep(value) {
  return JSON.parse(JSON.stringify(value));
}

function normalizeGameConfig(raw) {
  const config = raw && typeof raw === "object" ? raw : {};
  return {
    ...DEFAULT_GAME_CONFIG,
    ...config,
    initial: {
      ...DEFAULT_GAME_CONFIG.initial,
      ...(config.initial || {})
    },
    record: {
      ...DEFAULT_GAME_CONFIG.record,
      ...(config.record || {}),
      seal_penalty: {
        ...DEFAULT_GAME_CONFIG.record.seal_penalty,
        ...((config.record && config.record.seal_penalty) || {})
      }
    },
    rebellion: {
      ...DEFAULT_GAME_CONFIG.rebellion,
      ...(config.rebellion || {})
    },
    endings: {
      ...DEFAULT_GAME_CONFIG.endings,
      ...(config.endings || {})
    }
  };
}

async function loadGameData() {
  const cacheBust = Date.now();
  const withBust = (path) => `${path}?v=${cacheBust}`;

  const configPromise = fetch(withBust(DATA_PATHS.config), { cache: "no-store" })
    .then((res) => (res.ok ? res.json() : null))
    .catch(() => null);

  const [eventsRes, endingsRes, rawConfig] = await Promise.all([
    fetch(withBust(DATA_PATHS.events), { cache: "no-store" }),
    fetch(withBust(DATA_PATHS.endings), { cache: "no-store" }),
    configPromise
  ]);

  if (!eventsRes.ok) {
    throw new Error(`Failed to load events (${eventsRes.status})`);
  }
  if (!endingsRes.ok) {
    throw new Error(`Failed to load endings (${endingsRes.status})`);
  }

  EVENTS_DATA = await eventsRes.json();
  ENDINGS_DATA = await endingsRes.json();
  GAME_CONFIG = normalizeGameConfig(rawConfig);

  if (!Array.isArray(EVENTS_DATA)) {
    throw new Error("events.json must be an array");
  }
  if (!ENDINGS_DATA || !Array.isArray(ENDINGS_DATA.endings)) {
    throw new Error("endings.json must contain endings[]");
  }

  TOTAL_ROUNDS = Number(GAME_CONFIG.rounds) || 7;
  PRESSURE_GROWTH = Array.isArray(GAME_CONFIG.pressure_growth) && GAME_CONFIG.pressure_growth.length > 0
    ? GAME_CONFIG.pressure_growth.map((n) => Number(n) || 0)
    : [...DEFAULT_GAME_CONFIG.pressure_growth];
}

function createInitialGameState() {
  const initial = GAME_CONFIG.initial;
  return {
    round: 1,
    heaven: Number(initial.heaven) || 50,
    hell: Number(initial.hell) || 50,
    stability: Number(initial.stability) || 50,
    pressure: Number(initial.pressure) || 0,
    truthCounter: 0,
    sealPenaltyNextRound: false,
    rebellionFlag: false,
    rebellion: {
      consecutiveBalanceCount: 0,
      extremeChoiceCount: 0
    },
    events: [],
    history: [],
    language: "zh",
    phase: "event"
  };
}

document.addEventListener("DOMContentLoaded", () => {
  const prologue = document.getElementById("prologue");
  const title = document.getElementById("landing-title");
  const divider = document.getElementById("landing-divider");
  const ctaBtn = document.getElementById("cta-btn");
  const corners = document.querySelectorAll(".corner-mark");

  setTimeout(() => {
    prologue.classList.add("hide");
  }, 3500);

  setTimeout(() => {
    prologue.style.display = "none";
    title.classList.add("show");
    divider.classList.add("show");
  }, 5000);

  setTimeout(() => {
    ctaBtn.classList.add("show");
    corners.forEach((c) => c.classList.add("show"));
  }, 6800);
});

function startGame() {
  if (gameStarted) return;
  gameStarted = true;

  const landing = document.getElementById("landing");
  const gameContainer = document.getElementById("game-container");

  landing.classList.add("fade-out");

  setTimeout(() => {
    landing.style.display = "none";
    gameContainer.classList.add("active");
    showLoadingState();
    initGame().catch((error) => {
      gameStarted = false;
      showInitError(error);
    });
  }, 1200);
}

async function initGame() {
  await loadGameData();
  gameState = createInitialGameState();
  gameState.events = buildEventSequence(EVENTS_DATA);
  activeEndingId = null;
  updateLanguageControls();
  updateStatsUI();
  renderRound();
}

function showLoadingState() {
  const lang = document.documentElement.lang === "en" ? "en" : "zh";
  document.getElementById("event-title").textContent = TEXTS.loading[lang];
  document.getElementById("event-text").textContent = "";
  document.getElementById("choices-container").innerHTML = "";
  document.getElementById("record-phase").style.display = "none";
}

function showInitError(error) {
  const lang = document.documentElement.lang === "en" ? "en" : "zh";
  document.getElementById("event-title").textContent = TEXTS.initErrorTitle[lang];
  document.getElementById("event-text").textContent = `${TEXTS.initErrorBody[lang]} (${String(error.message || error)})`;
  document.getElementById("record-phase").style.display = "none";
  const choiceBox = document.getElementById("choices-container");
  choiceBox.innerHTML = "";
  const retryBtn = document.createElement("button");
  retryBtn.className = "choice-btn";
  retryBtn.type = "button";
  retryBtn.textContent = TEXTS.retry[lang];
  retryBtn.addEventListener("click", () => {
    showLoadingState();
    initGame().catch((nextError) => {
      gameStarted = false;
      showInitError(nextError);
    });
  });
  choiceBox.appendChild(retryBtn);
}

function buildEventSequence(allEvents) {
  const fixed1 = allEvents.find((e) => e.fixed_position === 1);
  const fixed6 = allEvents.find((e) => e.fixed_position === 6);
  const fixed7 = allEvents.find((e) => e.fixed_position === 7);

  if (!fixed1 || !fixed6 || !fixed7) {
    throw new Error("Missing required fixed-position events.");
  }

  const pool = allEvents.filter((e) => e.fixed_position === null);
  const picked = shuffle(pool).slice(0, 4);
  return [fixed1, ...picked, fixed6, fixed7];
}

function shuffle(items) {
  const list = [...items];
  for (let i = list.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [list[i], list[j]] = [list[j], list[i]];
  }
  return list;
}

function renderRound() {
  if (!gameState || gameState.phase === "ending") return;

  applySealPenaltyAtRoundStartIfNeeded();
  const currentEvent = getCurrentEvent();
  if (!currentEvent) return;

  const titleKey = gameState.language === "zh" ? "title_zh" : "title_en";
  const textKey = gameState.language === "zh" ? "text_zh" : "text_en";
  document.getElementById("event-title").textContent = currentEvent[titleKey];
  document.getElementById("event-text").textContent = currentEvent[textKey];

  renderChoices(currentEvent);
  renderRecordPanel();
  updateRoundIndicator();
  updateStatsUI();
}

function getCurrentEvent() {
  if (!gameState) return null;
  return gameState.events[gameState.round - 1] || null;
}

function getRoundHistory(round) {
  return gameState.history.find((item) => item.round === round) || null;
}

function applyEffect(effect) {
  if (!effect) return;
  gameState.heaven += Number(effect.heaven) || 0;
  gameState.hell += Number(effect.hell) || 0;
  gameState.stability += Number(effect.stability) || 0;
  gameState.pressure += Number(effect.pressure) || 0;
  clampAllStats();
}

function renderChoices(event) {
  const container = document.getElementById("choices-container");
  container.innerHTML = "";

  const roundHistory = getRoundHistory(gameState.round);
  const selectedChoiceId = roundHistory ? roundHistory.choiceId : null;
  const locked = gameState.phase !== "event";
  const labelKey = gameState.language === "zh" ? "label_zh" : "label_en";

  event.choices.forEach((choice) => {
    const btn = document.createElement("button");
    btn.className = `choice-btn${choice.is_extreme ? " extreme" : ""}`;
    btn.type = "button";
    btn.disabled = locked;

    if (!locked) {
      btn.addEventListener("click", () => handleChoice(choice.id));
    } else if (selectedChoiceId !== choice.id) {
      btn.style.opacity = "0.6";
    }

    const selectedTag = locked && selectedChoiceId === choice.id
      ? ` (${TEXTS.selected[gameState.language]})`
      : "";

    btn.innerHTML = `
      <span class="choice-id">${choice.id}</span>
      ${choice[labelKey]}${selectedTag}
    `;

    container.appendChild(btn);
  });
}

function handleChoice(choiceId) {
  if (!gameState || gameState.phase !== "event") return;

  const event = getCurrentEvent();
  if (!event) return;

  const choice = event.choices.find((item) => item.id === choiceId);
  if (!choice) return;

  applyEffect(choice.effect);
  if (choice.is_extreme) {
    gameState.rebellion.extremeChoiceCount += 1;
  }

  gameState.history.push({
    round: gameState.round,
    eventId: event.id,
    choiceId: choice.id,
    choiceExtreme: choice.is_extreme,
    choiceEffect: { ...choice.effect },
    recordAction: null,
    recordEffect: null,
    finalSnapshot: null
  });

  gameState.phase = "record";
  renderRound();
  showFeedback(`${TEXTS.effectPrefix[gameState.language]}: ${formatEffect(choice.effect)}`, 1800);
}

function renderRecordPanel() {
  const recordPhaseEl = document.getElementById("record-phase");
  const titleEl = document.getElementById("record-title");

  titleEl.textContent = gameState.language === "zh"
    ? "记录阶段 / Archive Phase"
    : "Archive Phase / 记录阶段";
  document.querySelectorAll("[data-en][data-zh]").forEach((el) => {
    el.textContent = el.dataset[gameState.language];
  });

  recordPhaseEl.style.display = gameState.phase === "record" ? "block" : "none";
}

function handleRecord(action) {
  if (!gameState || gameState.phase !== "record") return;
  if (!Object.prototype.hasOwnProperty.call(RECORD_ACTION_MAP, action)) return;

  const recordConfig = GAME_CONFIG.record;
  const recordEffect = { heaven: 0, hell: 0, stability: 0, pressure: 0 };
  let triggeredTruthBonus = false;

  if (action === "truth") {
    gameState.truthCounter += 1;
    if (gameState.truthCounter >= Number(recordConfig.truth_streak_target || 3)) {
      const bonus = Number(recordConfig.truth_stability_bonus || 3);
      gameState.stability += bonus;
      recordEffect.stability += bonus;
      gameState.truthCounter = 0;
      triggeredTruthBonus = true;
    }
  } else if (action === "polish") {
    const bonus = Number(recordConfig.polish_heaven_bonus || 2);
    gameState.heaven += bonus;
    recordEffect.heaven += bonus;
    gameState.truthCounter = 0;
  } else if (action === "blur") {
    const bonus = Number(recordConfig.blur_hell_bonus || 2);
    gameState.hell += bonus;
    recordEffect.hell += bonus;
    gameState.truthCounter = 0;
  } else if (action === "seal") {
    const delta = Number(recordConfig.seal_pressure_delta || -2);
    gameState.pressure += delta;
    recordEffect.pressure += delta;
    gameState.truthCounter = 0;
    if (Math.random() < Number(recordConfig.seal_penalty_chance || 0.2)) {
      gameState.sealPenaltyNextRound = true;
    }
  }

  clampAllStats();

  const roundHistory = getRoundHistory(gameState.round);
  if (roundHistory) {
    roundHistory.recordAction = action;
    roundHistory.recordEffect = recordEffect;
  }

  if (triggeredTruthBonus) {
    showFeedback(TEXTS.truthBonus[gameState.language], 2500);
  } else {
    showFeedback(`${TEXTS.effectPrefix[gameState.language]}: ${formatEffect(recordEffect)}`, 1400);
  }

  completeRound();
}

function completeRound() {
  updateRebellionTracker();

  const growth = PRESSURE_GROWTH[gameState.round - 1] || 0;
  gameState.pressure += growth;

  clampAllStats();

  const roundHistory = getRoundHistory(gameState.round);
  if (roundHistory) {
    roundHistory.finalSnapshot = {
      heaven: gameState.heaven,
      hell: gameState.hell,
      stability: gameState.stability,
      pressure: gameState.pressure,
      truthCounter: gameState.truthCounter
    };
  }
  updateStatsUI();

  if (gameState.round === TOTAL_ROUNDS) {
    const rbCfg = GAME_CONFIG.rebellion;
    gameState.rebellionFlag =
      gameState.rebellion.consecutiveBalanceCount >= Number(rbCfg.consecutive_required || 3) &&
      gameState.rebellion.extremeChoiceCount <= Number(rbCfg.max_extreme_choices || 1);
    showEnding(determineEnding(gameState));
    return;
  }

  gameState.round += 1;
  gameState.phase = "event";
  renderRound();
}

function updateRebellionTracker() {
  const rbCfg = GAME_CONFIG.rebellion;
  const balanced = Math.abs(gameState.heaven - gameState.hell) <= Number(rbCfg.balance_diff_max || 10);
  const stable = gameState.stability >= Number(rbCfg.stability_min || 65);

  if (balanced && stable) {
    gameState.rebellion.consecutiveBalanceCount += 1;
  } else {
    gameState.rebellion.consecutiveBalanceCount = 0;
  }
}

function applySealPenaltyAtRoundStartIfNeeded() {
  if (!gameState.sealPenaltyNextRound) return;

  const penalty = GAME_CONFIG.record.seal_penalty || { stability: -5, heaven: 3 };
  gameState.phase = "penalty";
  gameState.stability += Number(penalty.stability || -5);
  gameState.heaven += Number(penalty.heaven || 3);
  gameState.sealPenaltyNextRound = false;
  clampAllStats();
  updateStatsUI();
  showFeedback(TEXTS.sealPenalty[gameState.language], 2800);
  gameState.phase = "event";
}

function determineEnding(state) {
  const endingCfg = GAME_CONFIG.endings;
  if (state.stability < Number(endingCfg.stability_collapse_lt || 20)) return "human_collapse";
  if (state.heaven >= Number(endingCfg.heaven_dominance_gte || 90)) return "heaven_dominance";
  if (state.hell >= Number(endingCfg.hell_dominance_gte || 90)) return "hell_dominance";
  if (state.rebellionFlag && state.pressure < Number(endingCfg.rebellion_pressure_lt || 85)) return "human_rebellion";
  return "false_peace";
}

function showEnding(endingId) {
  const ending = ENDINGS_DATA.endings.find((item) => item.id === endingId);
  if (!ending) return;

  activeEndingId = endingId;
  gameState.phase = "ending";

  document.getElementById("ending-title").textContent = ending[`title_${gameState.language}`];
  document.getElementById("ending-text").textContent = ending[`text_${gameState.language}`];
  document.getElementById("ending-stats").innerHTML = `
    <div class="ending-stat">
      <div class="ending-stat-label">Heaven</div>
      <div class="ending-stat-value">${gameState.heaven}</div>
    </div>
    <div class="ending-stat">
      <div class="ending-stat-label">Hell</div>
      <div class="ending-stat-value">${gameState.hell}</div>
    </div>
    <div class="ending-stat">
      <div class="ending-stat-label">Stability</div>
      <div class="ending-stat-value">${gameState.stability}</div>
    </div>
    <div class="ending-stat">
      <div class="ending-stat-label">Pressure</div>
      <div class="ending-stat-value">${gameState.pressure}</div>
    </div>
  `;
  document.getElementById("ending-screen").classList.add("active");
}

function updateRoundIndicator() {
  const el = document.getElementById("round-indicator");
  if (!gameState) {
    el.textContent = `Round 1 / ${TOTAL_ROUNDS}`;
    return;
  }

  if (gameState.language === "en") {
    el.textContent = `Round ${gameState.round} / ${TOTAL_ROUNDS}`;
  } else {
    el.textContent = `${TEXTS.round.zh}${gameState.round}回合 / ${TOTAL_ROUNDS}`;
  }
}

function updateStatsUI() {
  if (!gameState) return;

  const stats = ["heaven", "hell", "stability", "pressure"];
  stats.forEach((key) => {
    const value = gameState[key];
    document.getElementById(`stat-${key}-val`).textContent = String(value);
    document.getElementById(`stat-${key}-bar`).style.width = `${value}%`;
  });
}

function toggleLanguage() {
  if (!gameState) return;
  gameState.language = gameState.language === "zh" ? "en" : "zh";
  document.documentElement.lang = gameState.language;
  updateLanguageControls();

  if (gameState.phase === "ending" && activeEndingId) {
    const ending = ENDINGS_DATA.endings.find((item) => item.id === activeEndingId);
    if (ending) {
      document.getElementById("ending-title").textContent = ending[`title_${gameState.language}`];
      document.getElementById("ending-text").textContent = ending[`text_${gameState.language}`];
    }
    return;
  }

  renderRound();
}

function updateLanguageControls() {
  const btn = document.getElementById("lang-toggle");
  if (!gameState || gameState.language === "zh") {
    btn.textContent = "EN / 中";
  } else {
    btn.textContent = "中 / EN";
  }
  updateRoundIndicator();
}

function formatEffect(effect) {
  const labelMap = STAT_LABELS[gameState.language];
  const lines = ["heaven", "hell", "stability", "pressure"]
    .filter((key) => Number(effect[key]) !== 0)
    .map((key) => `${labelMap[key]} ${effect[key] > 0 ? "+" : ""}${effect[key]}`);

  return lines.length > 0 ? lines.join(" | ") : TEXTS.noShift[gameState.language];
}

function clamp(value) {
  return Math.max(0, Math.min(100, value));
}

function clampAllStats() {
  gameState.heaven = clamp(gameState.heaven);
  gameState.hell = clamp(gameState.hell);
  gameState.stability = clamp(gameState.stability);
  gameState.pressure = clamp(gameState.pressure);
}

function showFeedback(text, duration = 2500) {
  const fb = document.getElementById("feedback");
  if (feedbackTimer) {
    clearTimeout(feedbackTimer);
  }
  fb.textContent = text;
  fb.classList.add("visible");
  feedbackTimer = setTimeout(() => {
    fb.classList.remove("visible");
    feedbackTimer = null;
  }, duration);
}
</script>

</body>
</html>
